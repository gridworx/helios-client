import * as fs from 'fs';
import * as path from 'path';
import { SpecRequirement, Scenario } from './spec-parser';

export interface TestAction {
  type: 'click' | 'fill' | 'select' | 'navigate' | 'upload' | 'wait' | 'expect' | 'screenshot';
  selector?: string;
  value?: string;
  description?: string;
}

export class TestGenerator {
  private outputDir: string;

  constructor(outputDir: string = path.join(__dirname, '../../../changes')) {
    this.outputDir = outputDir;
  }

  /**
   * Generate test file from spec requirements
   */
  async generateTestFile(
    changeName: string,
    requirements: SpecRequirement[]
  ): Promise<string> {
    const testContent = this.generateTestContent(changeName, requirements);
    const outputPath = path.join(
      this.outputDir,
      changeName,
      'tests',
      'generated',
      'spec.test.ts'
    );

    // Ensure directory exists
    const dir = path.dirname(outputPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Write test file
    fs.writeFileSync(outputPath, testContent);
    console.log(`âœ… Generated test: ${outputPath}`);

    return outputPath;
  }

  /**
   * Generate test content from requirements
   */
  private generateTestContent(
    changeName: string,
    requirements: SpecRequirement[]
  ): string {
    return `/**
 * Auto-generated tests for: ${changeName}
 * Generated: ${new Date().toISOString()}
 *
 * DO NOT EDIT - This file is automatically generated from OpenSpec
 */

import { test, expect, Page } from '@playwright/test';
import { AuthHelper } from '../../../testing/helpers/auth.helper';
import { DatabaseHelper } from '../../../testing/helpers/database.helper';
import { ScreenshotHelper } from '../../../testing/helpers/screenshot.helper';
import { TestDataHelper } from '../../../testing/helpers/test-data.helper';

const auth = new AuthHelper();
const db = new DatabaseHelper();
const screenshot = new ScreenshotHelper('${changeName}');
const testData = new TestDataHelper();

test.describe('${changeName}', () => {
  test.beforeAll(async () => {
    // Setup test environment
    await db.seed('${changeName}');
  });

  test.afterAll(async () => {
    // Cleanup
    await db.cleanup();
  });

${requirements.map(req => this.generateRequirementTests(req)).join('\n\n')}
});`;
  }

  /**
   * Generate tests for a requirement
   */
  private generateRequirementTests(requirement: SpecRequirement): string {
    return `  test.describe('${requirement.requirement}', () => {
    /**
     * Specification: ${requirement.file}
     * ${requirement.description}
     */

${requirement.scenarios.map((scenario, index) =>
  this.generateScenarioTest(requirement, scenario, index)
).join('\n\n')}
  });`;
  }

  /**
   * Generate test for a scenario
   */
  private generateScenarioTest(
    requirement: SpecRequirement,
    scenario: Scenario,
    index: number
  ): string {
    const testName = this.generateTestName(scenario);
    const testId = `${requirement.id}_${index}`;

    return `    test('${testName}', async ({ page }) => {
      const testId = '${testId}';

      // GIVEN
${scenario.given.map(given => this.generateGivenStep(given)).join('\n')}

      // WHEN
${scenario.when.map(when => this.generateWhenStep(when)).join('\n')}

      // THEN
${scenario.then.map(then => this.generateThenStep(then)).join('\n')}

      // Capture final screenshot
      await screenshot.capture(page, \`\${testId}_final\`);
    });`;
  }

  /**
   * Generate test name from scenario
   */
  private generateTestName(scenario: Scenario): string {
    if (scenario.when.length > 0) {
      return scenario.when[0]
        .replace(/[^a-zA-Z0-9\s]/g, '')
        .substring(0, 100);
    }
    return 'Test scenario';
  }

  /**
   * Generate Given step
   */
  private generateGivenStep(step: string): string {
    const actions = this.parseStepToActions(step, 'given');
    return actions
      .map(action => `      ${this.generateAction(action)}`)
      .join('\n');
  }

  /**
   * Generate When step
   */
  private generateWhenStep(step: string): string {
    const actions = this.parseStepToActions(step, 'when');
    return actions
      .map(action => `      ${this.generateAction(action)}`)
      .join('\n');
  }

  /**
   * Generate Then step
   */
  private generateThenStep(step: string): string {
    const actions = this.parseStepToActions(step, 'then');
    return actions
      .map(action => `      ${this.generateAction(action)}`)
      .join('\n');
  }

  /**
   * Parse step text into test actions
   */
  private parseStepToActions(step: string, type: 'given' | 'when' | 'then'): TestAction[] {
    const actions: TestAction[] = [];
    const stepLower = step.toLowerCase();

    // Authentication patterns
    if (stepLower.includes('logged in') || stepLower.includes('authenticated')) {
      if (stepLower.includes('admin')) {
        actions.push({
          type: 'navigate',
          description: 'Login as admin',
          value: `await auth.loginAsAdmin(page);`
        });
      } else {
        actions.push({
          type: 'navigate',
          description: 'Login as user',
          value: `await auth.loginAsUser(page);`
        });
      }
    }

    // Navigation patterns
    else if (stepLower.includes('navigate') || stepLower.includes('go to') || stepLower.includes('opens')) {
      const page = this.extractPageName(step);
      actions.push({
        type: 'navigate',
        description: `Navigate to ${page}`,
        value: `await page.goto('/${page}');`
      });
      actions.push({
        type: 'screenshot',
        value: `await screenshot.capture(page, '${page}_loaded');`
      });
    }

    // Click patterns
    else if (stepLower.includes('click') || stepLower.includes('press') || stepLower.includes('select')) {
      const element = this.extractElement(step);
      actions.push({
        type: 'click',
        description: `Click ${element}`,
        value: `await page.click('[data-test="${element}"]');`
      });
    }

    // Fill patterns
    else if (stepLower.includes('fill') || stepLower.includes('enter') || stepLower.includes('type')) {
      const field = this.extractField(step);
      const value = this.extractValue(step);
      actions.push({
        type: 'fill',
        description: `Fill ${field}`,
        value: `await page.fill('[data-test="${field}"]', '${value}');`
      });
    }

    // Upload patterns
    else if (stepLower.includes('upload') || stepLower.includes('attach')) {
      actions.push({
        type: 'upload',
        description: 'Upload file',
        value: `await page.setInputFiles('[data-test="file-upload"]', testData.getFile('sample.csv'));`
      });
    }

    // Assertion patterns
    else if (type === 'then') {
      if (stepLower.includes('should see') || stepLower.includes('displays') || stepLower.includes('shows')) {
        const text = this.extractExpectedText(step);
        actions.push({
          type: 'expect',
          description: `Verify ${text} is visible`,
          value: `await expect(page.locator('text=${text}')).toBeVisible();`
        });
      } else if (stepLower.includes('success')) {
        actions.push({
          type: 'expect',
          description: 'Verify success message',
          value: `await expect(page.locator('[data-test="success-message"]')).toBeVisible();`
        });
        actions.push({
          type: 'screenshot',
          value: `await screenshot.capture(page, 'success');`
        });
      } else if (stepLower.includes('error')) {
        actions.push({
          type: 'expect',
          description: 'Verify error message',
          value: `await expect(page.locator('[data-test="error-message"]')).toBeVisible();`
        });
      } else if (stepLower.includes('database') || stepLower.includes('stored')) {
        actions.push({
          type: 'expect',
          description: 'Verify database state',
          value: `// TODO: Add database verification\n      const result = await db.query('SELECT * FROM table WHERE condition');\n      expect(result.rows).toHaveLength(1);`
        });
      }
    }

    // Default: Add as comment for manual implementation
    if (actions.length === 0) {
      actions.push({
        type: 'navigate',
        description: step,
        value: `// TODO: Implement - ${step}`
      });
    }

    return actions;
  }

  /**
   * Generate action code
   */
  private generateAction(action: TestAction): string {
    if (action.value) {
      return action.value;
    }

    switch (action.type) {
      case 'click':
        return `await page.click('${action.selector}');`;
      case 'fill':
        return `await page.fill('${action.selector}', '${action.value}');`;
      case 'navigate':
        return `await page.goto('${action.value}');`;
      case 'screenshot':
        return `await screenshot.capture(page, '${action.description}');`;
      case 'expect':
        return `await expect(page.locator('${action.selector}')).toBeVisible();`;
      default:
        return `// ${action.description}`;
    }
  }

  /**
   * Extract page name from step
   */
  private extractPageName(step: string): string {
    const patterns = [
      /(?:to|opens?|navigates? to|goes? to)\s+(?:the\s+)?([a-z-]+)/i,
      /([a-z-]+)\s+(?:page|screen|view)/i
    ];

    for (const pattern of patterns) {
      const match = step.match(pattern);
      if (match) {
        return match[1].toLowerCase().replace(/\s+/g, '-');
      }
    }

    return 'page';
  }

  /**
   * Extract element identifier from step
   */
  private extractElement(step: string): string {
    const patterns = [
      /(?:clicks?|press|select)\s+(?:on\s+)?(?:the\s+)?"([^"]+)"/i,
      /(?:clicks?|press|select)\s+(?:on\s+)?(?:the\s+)?([a-z-]+)\s+button/i
    ];

    for (const pattern of patterns) {
      const match = step.match(pattern);
      if (match) {
        return match[1].toLowerCase().replace(/\s+/g, '-');
      }
    }

    return 'element';
  }

  /**
   * Extract field name from step
   */
  private extractField(step: string): string {
    const patterns = [
      /(?:fills?|enters?|types?)\s+(?:in\s+)?(?:the\s+)?([a-z]+)/i,
      /"([^"]+)"\s+field/i
    ];

    for (const pattern of patterns) {
      const match = step.match(pattern);
      if (match) {
        return match[1].toLowerCase().replace(/\s+/g, '-');
      }
    }

    return 'field';
  }

  /**
   * Extract value from step
   */
  private extractValue(step: string): string {
    const patterns = [
      /(?:with|as)\s+"([^"]+)"/i,
      /"([^"]+)"/
    ];

    for (const pattern of patterns) {
      const match = step.match(pattern);
      if (match) {
        return match[1];
      }
    }

    return 'test-value';
  }

  /**
   * Extract expected text from step
   */
  private extractExpectedText(step: string): string {
    const patterns = [
      /(?:see|shows?|displays?)\s+"([^"]+)"/i,
      /"([^"]+)"\s+(?:is\s+)?(?:visible|shown|displayed)/i
    ];

    for (const pattern of patterns) {
      const match = step.match(pattern);
      if (match) {
        return match[1];
      }
    }

    return 'expected text';
  }

  /**
   * Generate all tests for all changes
   */
  async generateAll(specs: Map<string, SpecRequirement[]>): Promise<string[]> {
    const generatedFiles: string[] = [];

    for (const [changeName, requirements] of specs) {
      const filePath = await this.generateTestFile(changeName, requirements);
      generatedFiles.push(filePath);
    }

    return generatedFiles;
  }
}

export default TestGenerator;